# -*- coding: utf-8 -*-
"""classificacao_RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cGWx34aN0Q3Vo2lcIZ-i9EH2uFJzNAQW
"""

import pandas as pd
import numpy as np
import shap
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report



"""<a href="https://colab.research.google.com/github/neryguilherme/thegamelibrary/blob/main/Classifica%C3%A7%C3%A3o_Mlp.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>"""

# Carregar os dados
banco = pd.read_parquet('/content/games_preprocessed.parquet')

banco

# prompt:  para cada linha na coluna "Genres" verifique se os valores "Indie", "Action", "Casual" estão presentes, caso existam mantenha eles na lista. Em seguida verifique se há outros valores que NÃO sejam "Indie", "Action", "Casual", caso existam substitua todos por "Outros". Em seguida ordene os valores da célula de acordo com a ordem seguinte: ["Indie","Action", "Casual", "Outros"]

def process_genres(genres_str):
    genres = []
    if isinstance(genres_str, str):
      genres = genres_str.split(',')

    processed_genres = []
    others_present = False

    for genre in genres:
        genre = genre.strip()
        if genre in ["Indie", "Action", "Casual"]:
            processed_genres.append(genre)
        elif genre != "":
            others_present = True

    if others_present:
        processed_genres.append("Outros")

    ordered_genres = []
    for target_genre in ["Indie", "Action", "Casual", "Outros"]:
      if target_genre in processed_genres:
        ordered_genres.append(target_genre)

    return ", ".join(ordered_genres)


banco['Genres'] = banco['Genres'].apply(process_genres)
banco['Genres']

# Preenchimento de valores faltantes
for col in banco.columns:
    if banco[col].dtype == 'object':
        banco[col] = banco[col].fillna(banco[col].mode()[0])  # Preenche com a moda
    elif pd.api.types.is_numeric_dtype(banco[col]):
        banco[col] = banco[col].fillna(banco[col].median())  # Preenche com a mediana
banco

# prompt: aplique o label encoder nos atributos

# Aplicar Label Encoding aos atributos categóricos
label_encoders = {}
x_column = banco.copy()
for column in x_column.select_dtypes(include=['object']).columns:
    le = LabelEncoder()
    x_column[column] = le.fit_transform(x_column[column])
    label_encoders[column] = le
x_column

X = x_column.drop(columns=['Genres'])
X.columns

# Escalonar os dados numéricos
scaler = StandardScaler()
numerical_cols = X.select_dtypes(include=['number']).columns
X[numerical_cols] = scaler.fit_transform(X[numerical_cols])
X

#y = le.fit_transform(name_column)
k = x_column['Genres'] #Definindo k para a coluna Genres
k = le.fit_transform(k)
k

# Dividir os dados em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, k, test_size=0.2)

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences

# ... (Your existing code for data loading and preprocessing) ...

# Prepare data for RNN
# Assuming 'Genres' is already label encoded (k)
max_words = 1000  # Adjust based on vocabulary size
tokenizer = Tokenizer(num_words=max_words, oov_token="<OOV>")
tokenizer.fit_on_texts(x_column['Genres'].astype(str))
sequences = tokenizer.texts_to_sequences(x_column['Genres'].astype(str))
padded_sequences = pad_sequences(sequences, padding='post', truncating='post', maxlen=5)


X_train_rnn, X_test_rnn, y_train_rnn, y_test_rnn = train_test_split(padded_sequences, k, test_size=0.2, random_state=42)


# RNN Model
model = Sequential()
model.add(Embedding(max_words, 8, input_length=5)) # adjust embedding dimension
model.add(LSTM(64))
model.add(Dense(len(np.unique(k)), activation='softmax')) # output layer with softmax
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
model.summary()

# Training
model.fit(X_train_rnn, y_train_rnn, epochs=10, validation_data=(X_test_rnn, y_test_rnn))


# Evaluate the Model
y_pred_rnn_prob = model.predict(X_test_rnn)
y_pred_rnn = np.argmax(y_pred_rnn_prob, axis=1)
print(classification_report(y_test_rnn, y_pred_rnn, zero_division=0.0))


accuracy_rnn = accuracy_score(y_test_rnn, y_pred_rnn)
precision_rnn = precision_score(y_test_rnn, y_pred_rnn, average='weighted', zero_division=0.0)
recall_rnn = recall_score(y_test_rnn, y_pred_rnn, average='weighted', zero_division=0.0)
f1_rnn = f1_score(y_test_rnn, y_pred_rnn, average='weighted', zero_division=0.0)

print(f"RNN Accuracy: {accuracy_rnn}")
print(f"RNN Precision: {precision_rnn}")
print(f"RNN Recall: {recall_rnn}")
print(f"RNN F1-score: {f1_rnn}")